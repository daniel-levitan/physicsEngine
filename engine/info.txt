Intro
═════

Essa é a base para a criação de um motor de física em C/C++. Estou me baseando na lista 2D Physics Engine Tutorial https://youtu.be/D3oQ8mUF_84?si=UCfUcV2FHuknAqF-

Esta lista foi escrita para JavaScript, por isso estou adaptando para C++. 

Para cada etapa, talvez eu tenha de fazer testes separados.

Modificações e adaptações
═════════════════════════

Fiz diversas modificações no código para se encaixar em Orientação a Objeto.

1. Primeiro o que foi feito foi criar as classes shape, polygon, rectangle e circle em seus arquivos separadamente. A classe shape tem o método draw determinado como virtual, que permite que as classes derivadas sobrescrevam este método. Usa-se a palavra override nas funções das classes herdeiras para informar ao compilador o que está acontecendo e para dar maior visibilidade no código.

Cada função draw recebe um renderer como parâmetro, já que um renderer não é criado na classe e não precisa ser armazenado nela.

2. Criei uma classe engine para encapsular o motor. Isso provê a separação de temas no projeto.

3. Fiz o encapsulamento das funções SDL. Isso vai me permitir usar smart pointers para lidar com gerenciamento de memória.

4. Fiz a separação das funções que lidam com o gerenciamento de entradas.


Tópicos de Física e Matemática
══════════════════════════════

Calculando o centro geométrico de um corpo(shape)
─────────────────────────────────────────────────

Para o círculo isso é fácil, é o centro da figura. Para retângulos também, é onde as duas diagonais se interceptam. Para polígonos em geral não é tão imediato.

C_x = 1/6A * SUM _i=0 ^n-1 (x_i + x_(i+1)) * (x_i • y_(i+1) - y_i • x_(i+1))

A = 1/2 * SUM _i=0 ^n-1 (x_i • y_(i+1) - y_i • x_(i+1))

Referência: https://en.wikipedia.org/wiki/Polygon -> área e centróide


Rotacionar pontos 
─────────────────

Aqui usamos duas relações matemáticas:
	direction = vector_we_want_to_rotate - point_around_which_the_rotation_will_happen
	x = x * cos(radians) -  direction.y * sin(radians)
	y = x * sin(radians) +  direction.y * cos(radians)
	

Detecção de colisão
───────────────────

Detecção de colisão de círculos
-------------------------------
Para o círculo: a distância entre os centros deve ser menor que a soma dos raios para haver colisão.

Profundidade de colisão
-----------------------
Podemos calcular a distância entre os centros e diminuir a soma dos raios. Isso dará um valor negativo. Ou podeos somar os raios e diminuir da distância entre os círculos, isso nos dará a distância de penetração.

Como afastar um círculo do outro
--------------------------------
Considerando que um círculo entrou no outro, precisamos conhecer essa profundidade de colisão. Depois vamos diminuir um raio do outro e vamos normalizar esse vetor. Multiplicamos o resultado da normalização pela profundidade e finalmente obtemos o afastamento que queremos.

Normal num polígono
-------------------
Em um polígono, a força normal sai de cada uma de suas arestas.



Tópicos para estudar
════════════════════
1. std::unique_ptr: Isso é técnica nova de C++.
2. Lambda functions em C++.
3. move semantics.
4. Herança e polimorfismo. Estou usando direto.

Open Tasks
══════════
1. Ainda não lidei com a criação de setas ao apertar o mouse. Está num arquivo separado.
2. Escrever(SDL_TFF) no gráfico também está num arquivo separado.
3. Eu não sei se devo separar a class Engine do programa main. Tenho uma pasta src dentro de engine, é a única que está assim.
4. Estou pensando se vale a pena deixar de usar ownership.
5. Não sei se as funções de cálculo de centróide e área deveriam estar dentro da classe Shape. Também não sei porquê não calcular a área e a centróide assim que o objeto é instanciado. Talvez porque não seja necessário calcular. 
6. A fórmula do cálcula da área e da centróide se confundem. Não sei se a área será usada para algo depois, mas calcular separadamente diminui a eficiência de O(n) para O(n^2).
7. drawings.cpp tem de ser um namespace.



